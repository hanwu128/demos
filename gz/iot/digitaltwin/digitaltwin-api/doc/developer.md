# 开发者文档

此文档提供给开发者阅读。


## 关于开放API版本管理的思考

API版本管理的重要性不言而喻，对于API的设计者和使用者而言，版本管理都有着非常重要的意义。
首先，对于API的设计和实现者而言，需要考虑向后兼容性，但是随着业务的发展和需求的变更往往会导致兼容性实现非常复杂，因此引入API版本管理将能解决这个尴尬。此时可以提供多个版本的API实现，不需要再为了向后兼容性而绞尽脑汁。
其次，对于API的使用者而言，也可以灵活选择使用不同版本API，而不用担心API的兼容性问题。

那么，如何对API实现版本管理呢？
目前已经有许多成熟的做法，比如：将版本信息放在URL中，或者放在HTTP消息头中，甚至可以放在URL参数中。各有利弊，不同的版本管理方式实现难易程度各异。将版本信息放在URL中虽然破坏了REST的架构风格，但是因版本不同而带来的变化在URL中就能体现，更加直观。而将版本信息方在HTTP请求头或者URL参数中，好处是保持URL不变，但是API实现者需要解析传递的版本参数调用不同的实现方法。

结合项目的实际情况，在本项目中使用将版本信息放在URL中的方式进行版本管理，这样做是基于如下几点考虑：
1. API的变化直接在URL中体现，直观明了，也不用解析版本参数。
2. 对应不同版本的URL可能需要传递不同的参数，这样对于API实现者而言是在不同的Controller方法中解析的，不用考虑在解析请求参数时的兼容性，实现简单。
3. 项目中使用的Spring框架对于URL版本管理这种方式原生支持就比较好，不需要做其他适配工作。


## 关于Web过滤器执行顺序的设计

所有的Web Filter都放在包`com.lenovo.iot.digitaltwin.filter`下，使用Tomcat提供的注解`@WebFilter`进行注册。为了控制Filter的执行顺序，有2种方法：
1. 使用其默认规则，通过Filter类名称首字母按字母序执行
2. 将Filter注册到Spring容器中，明确设置执行顺序

考虑到代码的可维护性，使用默认规则，在每一个Filter前面添加一个对应的英文字母。如：ATokenFilter，BCROSFilter，前者将在后者之前执行。



## 关于处理数据库自动升级的实现

由于Spring Boot框架支持数据库操作，在启动程序时可以执行指定的SQL文件。利用这个特性，将相关SQL语句统一在一个文件中，并在Spring Boot的配置文件中（以application.properties为例）配置如下属性：
```text
# 关闭hibernate自动处理ddl
spring.jpa.hibernate.ddl-auto=none
# 指定需要执行的SQL文件路径
spring.datasource.schema=classpath:sql/schema-*-mysql.sql
# 是否在启动时执行SQL文件
spring.datasource.initialization-mode=always
# 执行SQL文件出错时是否继续启动应用程序
spring.datasource.continue-on-error=true
```

约定如下：
1. 将数据库表的创建语句统一放到名称为`schema-create-mysql.sql`文件中。
2. 将数据库表的升级语句（如：添加列，删除列等）统一放到名称为`schema-update-mysql.sql`的文件中。


**注意：**
上述2个SQL文件中必须有SQL语句，否则启动时将会报错。因此，文件`schema-create-mysql.sql`会一直存在，便于在新的环境中初始化创建表；文件`schema-update-mysql.sql`在需要升级表的时候再添加，并且确保在其中一定要存在SQL语句。


## 关于前端API接口业务状态码的扩展

对于前端API而言，HTTP状态码只有一个：200。基本的业务状态码使用对应语义的HTTP标准状态码，如：404表示资源不存在，400表示参数错误等等。在此基础上扩展了一些新的业务状态码，基本原则如下：
- 客户端错误：在400基础上扩展，标准HTTP状态码目前使用的“400”状态码最大值为417，为了避免冲突，新扩展的业务状态码从419开始，根据需求依次增加值。
- 服务端错误：在500基础上扩展，标准HTTP状态码目前使用的“500”状态码最大值为505，为了避免冲突，新扩展的业务状态码从510开始，根据需求依次增加值。

完整的业务状态码定义见前端API接口文档描述。
HTTP状态码参考rfc2616：https://www.ietf.org/rfc/rfc2616.txt


## 关于容器化支持打包

原本基于Spring Boot框架的项目原生支持Maven插件打包为Docker镜像，但是由于当前的部署环境不需要直接从源码构建镜像这种方式，而是直接打包为一个可安装的tar包形式。
为了能最大化灵活地支持容器化打包，因此将打包脚本独立出来，当需要容器化部署时，使用脚本`docker.sh`进行打包。将来如果有需要修改容器化支持的打包方式，只需要修改`docker.sh`脚本即可。
普通的安装包还是通过`build.sh`进行打包。




